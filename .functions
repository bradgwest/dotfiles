#!/bin/bash

create-pkcs8-key() {
  openssl genrsa -out $1.pem 4096
  openssl rsa -in $1.pem -pubout -out $1-pub.pem
  openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in $1.pem -out $1-pkcs8.pem
}

# Reading list
add-to-reading() {
    echo $1 >> ~/reading.md
}

# Git
clone () {
  git fetch origin pull/$1/head:pr_$1
  git checkout pr_$1
}

gfpr () {
  git fetch origin pull/$1/head:PR-$1
  git checkout PR-$1
}

# Git - Clone a PR so that you can add commits and push to it
# $1 -- fork to pull from, like https://github.com/bradwest-wk/dataflow_catapult.git or ssh equivalent
# $2 -- branch name, like ANSER-8765
clone-to-contribute () {
  REMOTE_ALIAS=$(echo $1 | perl -ne 'print "$&\n" if /(?<=github.com[\/:])[a-z\-]+/')
  git remote add $REMOTE_ALIAS $1 || true
  git fetch $REMOTE_ALIAS
  git checkout -b $2 $REMOTE_ALIAS/$2
  echo "Make changes and run 'git push $REMOTE_ALIAS $2' to update the PR"
}

# ISO08061 UTC timestamp
timestamp() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Write a notes taker
note() {
  # if $NOTES doesn't exist, then error
  if [ -z "${NOTES}" ]; then
    echo "Please set NOTES env variable"
    exit 1
  fi

  if ! (($#)); then
    # no args, tail
    tail $NOTES
  else
    # add all args to the file
    printf "$(timestamp) %s\n" "$*" >> $NOTES
  fi
}

# function cd() {
#   builtin cd "$@"
# 
#   if [[ -z "$VIRTUAL_ENV" ]] ; then
#     ## If env folder is found then activate the vitualenv
#       if [[ -d ./.env ]] ; then
#         source ./.env/bin/activate
#       fi
#   else
#     ## check the current folder belong to earlier VIRTUAL_ENV folder
#     # if yes then do nothing
#     # else deactivate
#       parentdir="$(dirname "$VIRTUAL_ENV")"
#       if [[ "$PWD"/ != "$parentdir"/* ]] ; then
#         deactivate
#       fi
#   fi
# }

# cd and ls in one
cl() {
  local dir="$1"
  local dir="${dir:=$HOME}"
  if [[ -d "$dir" ]]; then
    cd "$dir" >/dev/null; ls
  else
    echo "bash: cl: $dir: Directory not found"
  fi
}

# calculator
calc() {
    echo "scale=3;$@" | bc -l
}

# Take a TODO note in cwd
todo() {
    local dir="${PWD}/.todo"
    if [[ -z "$dir" ]]; then
        touch "$dir"
    fi

    if ! (($#)); then
        cat "$dir"
    else
        printf "$(timestamp) %s\n" "$*" >> "$dir"
    fi
}

# delete a line from $HISTFILE. If no arg is passed, then it deletes the
# previous command, otherwise it attempts to match the args to a line
forget() {
  if ! (($#)); then
    # no args, delete previous
    history -d $(expr $(history | tail -n 1 | grep -oP '^\s+\d+') - 1);
  else
    # implement me
    echo Not Implemented
  fi
}

# Create python3 venv in ./.venv
# $1 - path to python binary
# $2 - name of virtualenv
create-venv () {
  if [[ $# -ne 2 ]]; then
    echo "Must pass 2 parameters, (1) python binary and (2) name of venv"
    exit 1
  fi
  $1 -m venv $PWD/.venv/$2
  source $PWD/.venv/$2/bin/activate
  pip install wheel
}

# Create python2 venv in ./venv
# $1 - path to python binary
# $2 - name of virtualenv
create-venv2 () {
  if [[ $# -ne  2 ]]; then
    echo "Must pass 2 parameters, (1) python binary and (2) name of venv"
    return 1
  fi
  python2 -m virtualenv -p $1 $PWD/.venv/$2
}

# Activate a virtual env
# $1 path to venv, within .venv directory
venv () {
  local usage="Usage: venv <virtualenv>"

  if [[ -d venv ]]; then
    . venv/bin/activate
    return 0
  fi

  if [[ ! -d .venv ]]; then
    echo "ERROR: .venv/ directory does not exist"
    return 1
  fi

  if [[ $# > 1 ]]; then
    echo "Too many args:\n$usage"
    return 1
  fi

  local subdirs=$(ls -d -- .venv/*/ | xargs basename)

  if [[ $# -eq 0 && $(echo $subdirs | wc -w) -ne 1 ]]; then
    echo "Virtualenvs in directory:\n$subdirs"
    return 0
  fi

  local venvpath=.venv/

  if [[ $# -eq 1 ]]; then
    venvpath+=$(echo $1 | sed 's/ *$//g')
  else
    venvpath+=$subdirs
  fi

  . ${venvpath}/bin/activate
}

# Set redshift creds
_set-rs() {
    if [[ $# -ne 5 ]]; then
        echo "usage: _set_rs <host> <db> <port> <user> <pw>"
        return 1
    fi

    export REDSHIFT_HOST="$1"
    export REDSHIFT_DB="$2"
    export REDSHIFT_PORT="$3"
    export REDSHIFT_USER="$4"
    export REDSHIFT_PW="$5"
}

# set dbt user
_set-dbt() {
    if [[ $# -ne 2 ]]; then
        echo "usage: _set-dbt <user> <pw>"
    fi

    export DBT_USER="$1"
    export DBT_PASSWORD="$2"
}

# Switch dbt user
#
# $1 the user to set
dbt-user () {
    case "$1" in

    dev)
        _set-dbt \
            $_REDSHIFT_PROD_DBT_USER \
            $_REDSHIFT_PROD_DBT_PW
        ;;


    admin)
        _set-dbt \
            $_REDSHIFT_PROD_READ_WRITE_USER \
            $_REDSHIFT_PROD_READ_WRITE_PW
        ;;


    *)
        echo "usage: dbt-user <admin|dev>"
        return 1

    esac
}

# Switch redshift users
#
# Requires a number of env vars to be set
# $1 the environment to set
# $2 the user to set
rs-user () {
    case "$1:$2" in

    stg:ro)
        _set-rs \
            $_REDSHIFT_STG_HOST \
            $_REDSHIFT_STG_DB \
            $_REDSHIFT_STG_PORT \
            $_REDSHIFT_STG_READ_ONLY_USER \
            $_REDSHIFT_STG_READ_ONLY_PW
        ;;


    stg:run)
        _set-rs \
            $_REDSHIFT_STG_HOST \
            $_REDSHIFT_STG_DB \
            $_REDSHIFT_STG_PORT \
            $_REDSHIFT_STG_RUN_USER \
            $_REDSHIFT_STG_RUN_PW
        ;;

    stg:dbt)
        _set-rs \
            $_REDSHIFT_STG_HOST \
            $_REDSHIFT_STG_DB \
            $_REDSHIFT_STG_PORT \
            $_REDSHIFT_STG_DBT_USER \
            $_REDSHIFT_STG_DBT_PW
        ;;


    prod:ro)
        _set-rs \
            $_REDSHIFT_PROD_HOST \
            $_REDSHIFT_PROD_DB \
            $_REDSHIFT_PROD_PORT \
            $_REDSHIFT_PROD_READ_ONLY_USER \
            $_REDSHIFT_PROD_READ_ONLY_PW
        ;;

    prod:run)
        _set-rs \
            $_REDSHIFT_PROD_HOST \
            $_REDSHIFT_PROD_DB \
            $_REDSHIFT_PROD_PORT \
            $_REDSHIFT_PROD_RUN_USER \
            $_REDSHIFT_PROD_RUN_PW
        ;;

    prod:dbt)
        _set-rs \
            $_REDSHIFT_PROD_HOST \
            $_REDSHIFT_PROD_DB \
            $_REDSHIFT_PROD_PORT \
            $_REDSHIFT_PROD_DBT_USER \
            $_REDSHIFT_PROD_DBT_PW
        ;;

    prod:rw)
        _set-rs \
            $_REDSHIFT_PROD_HOST \
            $_REDSHIFT_PROD_DB \
            $_REDSHIFT_PROD_PORT \
            $_REDSHIFT_PROD_READ_WRITE_USER \
            $_REDSHIFT_PROD_READ_WRITE_PW
        ;;


    *)
        echo "usage: rs-user <stg|prod> <run|ro|dbt>"
        return 1

    esac

}

# Redshift psql
rspsql () {
   PGPASSWORD="${REDSHIFT_PW}" \
    psql \
    -h ${REDSHIFT_HOST} \
    -U ${REDSHIFT_USER} \
    -d ${REDSHIFT_DB} \
    -p ${REDSHIFT_PORT} 
}

# Query production redshift
#
# Requires that you have a 'redshift-prod' alias setup that connects and
# executes the psql command
# $1 input file
# $2 output file. If left off, then will write as csv to stdout
# $3
# TODO
# * implement a log
# * write to results directory
# * write same filename
# * add timestamp if no filename passed
qrs () {
    if [[ $# -eq 0 ]]; then
        echo "usage: qrs <input-file> <output-file> ...\nuse rs-psql to get a pqsl terminal"
        return 1
    fi

    # create a results directory
    if [ ! -d "results" ]; then
        mkdir results
    fi
 
    # if no output file passed, write results to a csv file with same name in results directory
    if [[ $# -eq 1 ]]; then
        # local bn=$(basename $1)
        echo $1
        local args="-f ${1}" # -o results/${bn}_$(timestamp).csv"
    else
        local args="-f ${1} -o ${2}"
    fi

    cmd="PGPASSWORD=\"${REDSHIFT_PW}\" psql \
        -h \"${REDSHIFT_HOST}\" \
        -U \"${REDSHIFT_USER}\" \
        -d \"${REDSHIFT_DB}\" \
        -p \"${REDSHIFT_PORT}\" \
        --csv ${args} ${@:3}"

    eval $cmd
}

